<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>aDTN lib: lib/api/include/adtn.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">aDTN lib
   &#160;<span id="projectnumber">0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a4f29b99a4f7418161f089241a24c9b5.html">api</a></li><li class="navelem"><a class="el" href="dir_c68aa2dfb32282b1eebfafa3d8ceb711.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">adtn.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsock__addr__t.html">sock_addr_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a42d1d70144e1933c56cdb4fef2b6d059"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42d1d70144e1933c56cdb4fef2b6d059"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OP_PROC_FLAGS</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a42d1d70144e1933c56cdb4fef2b6d059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d8ad340104fb20f1bb1d15f135b8fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5d8ad340104fb20f1bb1d15f135b8fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OP_LIFETIME</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aa5d8ad340104fb20f1bb1d15f135b8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f79772f6dcea2a8d1f68f0b2d9bce7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82f79772f6dcea2a8d1f68f0b2d9bce7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OP_BLOCK_FLAGS</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a82f79772f6dcea2a8d1f68f0b2d9bce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33483653abfd256f72f4e5951e192588"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33483653abfd256f72f4e5951e192588"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OP_DEST</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a33483653abfd256f72f4e5951e192588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa715296007ccf4c7b06ef71ec4a77b56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa715296007ccf4c7b06ef71ec4a77b56"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OP_SOURCE</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:aa715296007ccf4c7b06ef71ec4a77b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9007620da092e7b8166bc7a11c8e1710"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9007620da092e7b8166bc7a11c8e1710"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OP_REPORT</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a9007620da092e7b8166bc7a11c8e1710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201d0b14a45e49e5d4e5638a9065b0fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a201d0b14a45e49e5d4e5638a9065b0fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OP_CUSTOM</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:a201d0b14a45e49e5d4e5638a9065b0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f71368a3e557a0167b92eacfb275e0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f71368a3e557a0167b92eacfb275e0f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OP_LAST_TIMESTAMP</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a2f71368a3e557a0167b92eacfb275e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5f3b9e8c428a78ba02cb8c8898d8490c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#a5f3b9e8c428a78ba02cb8c8898d8490c">adtn_socket</a> ()</td></tr>
<tr class="memdesc:a5f3b9e8c428a78ba02cb8c8898d8490c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a adtn sockets to send or recv information using the adtn platform with the default configuration.  <a href="#a5f3b9e8c428a78ba02cb8c8898d8490c">More...</a><br/></td></tr>
<tr class="separator:a5f3b9e8c428a78ba02cb8c8898d8490c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa097626513dd6ffd3e781adcf7d31e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#aaa097626513dd6ffd3e781adcf7d31e2">adtn_socket</a> (const char *config_file)</td></tr>
<tr class="memdesc:aaa097626513dd6ffd3e781adcf7d31e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a adtn sockets to send or recv information using the adtn platform.  <a href="#aaa097626513dd6ffd3e781adcf7d31e2">More...</a><br/></td></tr>
<tr class="separator:aaa097626513dd6ffd3e781adcf7d31e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8928a10e0adc936b202de9b2c5a251"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#a4a8928a10e0adc936b202de9b2c5a251">adtn_setcodopt</a> (int fd, int option_name, const char *code)</td></tr>
<tr class="memdesc:a4a8928a10e0adc936b202de9b2c5a251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate codes to a socket.  <a href="#a4a8928a10e0adc936b202de9b2c5a251">More...</a><br/></td></tr>
<tr class="separator:a4a8928a10e0adc936b202de9b2c5a251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e74a5f6f5753fba19c1f819409f0fa4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#a5e74a5f6f5753fba19c1f819409f0fa4">adtn_setcodopt</a> (int fd, int option_name, const char *code, int from_file)</td></tr>
<tr class="memdesc:a5e74a5f6f5753fba19c1f819409f0fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate codes to a socket.  <a href="#a5e74a5f6f5753fba19c1f819409f0fa4">More...</a><br/></td></tr>
<tr class="separator:a5e74a5f6f5753fba19c1f819409f0fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc689259089066625ac4e162d2eaa38a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#afc689259089066625ac4e162d2eaa38a">adtn_setcodopt</a> (int fd, int option_name, const char *code, int from_file, int replace)</td></tr>
<tr class="memdesc:afc689259089066625ac4e162d2eaa38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate codes to a socket.  <a href="#afc689259089066625ac4e162d2eaa38a">More...</a><br/></td></tr>
<tr class="separator:afc689259089066625ac4e162d2eaa38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d939eb435ace00aed9481fa2206fd2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#a7d939eb435ace00aed9481fa2206fd2b">adtn_bind</a> (int fd, <a class="el" href="structsock__addr__t.html">sock_addr_t</a> *addr)</td></tr>
<tr class="memdesc:a7d939eb435ace00aed9481fa2206fd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the information given to the socket.  <a href="#a7d939eb435ace00aed9481fa2206fd2b">More...</a><br/></td></tr>
<tr class="separator:a7d939eb435ace00aed9481fa2206fd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbfe924aaed4e0f46d39f2c9aecab79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#aacbfe924aaed4e0f46d39f2c9aecab79">adtn_close</a> (int fd)</td></tr>
<tr class="memdesc:aacbfe924aaed4e0f46d39f2c9aecab79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an adtn_socket and frees the memory associated to the socket.  <a href="#aacbfe924aaed4e0f46d39f2c9aecab79">More...</a><br/></td></tr>
<tr class="separator:aacbfe924aaed4e0f46d39f2c9aecab79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad717021a3a6e4ea0d5daeb0067976215"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#ad717021a3a6e4ea0d5daeb0067976215">adtn_shutdown</a> (int fd)</td></tr>
<tr class="memdesc:ad717021a3a6e4ea0d5daeb0067976215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as adtn_close(1), deleting also waiting data.  <a href="#ad717021a3a6e4ea0d5daeb0067976215">More...</a><br/></td></tr>
<tr class="separator:ad717021a3a6e4ea0d5daeb0067976215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cad55c5318074fb976e192a9aef2a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#af4cad55c5318074fb976e192a9aef2a4">adtn_rmcodopt</a> (int fd, const int option)</td></tr>
<tr class="memdesc:af4cad55c5318074fb976e192a9aef2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an associated code from a socket.  <a href="#af4cad55c5318074fb976e192a9aef2a4">More...</a><br/></td></tr>
<tr class="separator:af4cad55c5318074fb976e192a9aef2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e2c186f096e9aad28705002b212729"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#a62e2c186f096e9aad28705002b212729">adtn_setsockopt</a> (int fd, const int optname, const void *optval)</td></tr>
<tr class="memdesc:a62e2c186f096e9aad28705002b212729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set message options.  <a href="#a62e2c186f096e9aad28705002b212729">More...</a><br/></td></tr>
<tr class="separator:a62e2c186f096e9aad28705002b212729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd93d68c5305c0d57e7f742ec51bb88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#aebd93d68c5305c0d57e7f742ec51bb88">adtn_getsockopt</a> (int fd, const int optname, void *optval, int *optlen)</td></tr>
<tr class="memdesc:aebd93d68c5305c0d57e7f742ec51bb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get message options.  <a href="#aebd93d68c5305c0d57e7f742ec51bb88">More...</a><br/></td></tr>
<tr class="separator:aebd93d68c5305c0d57e7f742ec51bb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418c2b08965709b2ee2e3fc677163b11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#a418c2b08965709b2ee2e3fc677163b11">adtn_sendto</a> (int fd, const void *buffer, size_t buffer_l, const <a class="el" href="structsock__addr__t.html">sock_addr_t</a> addr)</td></tr>
<tr class="memdesc:a418c2b08965709b2ee2e3fc677163b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message over ADTN platform.  <a href="#a418c2b08965709b2ee2e3fc677163b11">More...</a><br/></td></tr>
<tr class="separator:a418c2b08965709b2ee2e3fc677163b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad4189d4d9c65c2ccba478f6bcf184d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#abad4189d4d9c65c2ccba478f6bcf184d">adtn_recv</a> (int fd, void *buffer, size_t len)</td></tr>
<tr class="memdesc:abad4189d4d9c65c2ccba478f6bcf184d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recive a message.  <a href="#abad4189d4d9c65c2ccba478f6bcf184d">More...</a><br/></td></tr>
<tr class="separator:abad4189d4d9c65c2ccba478f6bcf184d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299b065f549a34acddf22976959737fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adtn_8h.html#a299b065f549a34acddf22976959737fd">adtn_recvfrom</a> (int fd, void *buffer, size_t len, <a class="el" href="structsock__addr__t.html">sock_addr_t</a> *addr)</td></tr>
<tr class="memdesc:a299b065f549a34acddf22976959737fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recive a message, filling sender information.  <a href="#a299b065f549a34acddf22976959737fd">More...</a><br/></td></tr>
<tr class="separator:a299b065f549a34acddf22976959737fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7d939eb435ace00aed9481fa2206fd2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsock__addr__t.html">sock_addr_t</a> *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associates the information given to the socket. </p>
<p>When adtn socket is created with adtn_socket(1) it exist in the space name but has no address associated. adtn_bind(2) associates the information specified in the structure <a class="el" href="structsock__addr__t.html">sock_addr_t</a> of the second argument to the socket represented by the file descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor that identifies the adtn_socket. This value can be obtained calling adtn_socket(1). </td></tr>
    <tr><td class="paramname">address</td><td>A <a class="el" href="structsock__addr__t.html">sock_addr_t</a> structure containing information about the address that must be associated with the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>ENOENT cannot load the shared memory. </li>
<li>EACCES the program hasn't enough permissions to create bind the socket. </li>
<li>EADDRINUSE the address is already in use. </li>
</ul>

</div>
</div>
<a class="anchor" id="aacbfe924aaed4e0f46d39f2c9aecab79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes an adtn_socket and frees the memory associated to the socket. </p>
<p>Closes an adtn_socket and frees the memory associated to the socket. The structures associated to the socket in adtn_bind(2) call are freed too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>EACCES the program hasn't enough permisions to eliminate the socket. </li>
</ul>

</div>
</div>
<a class="anchor" id="aebd93d68c5305c0d57e7f742ec51bb88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_getsockopt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get message options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket. </td></tr>
    <tr><td class="paramname">optname</td><td>determines the option to set, the possible values are listed below. </td></tr>
    <tr><td class="paramname">optval</td><td>where to save the value obtined. </td></tr>
    <tr><td class="paramname">optlen</td><td>number of bytes to get, after calling is set to the number of bytes returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>Options available: </p>
<pre class="fragment"> OP_PROC_FLAGS       Get the flags for the primary block.
 OP_LIFETIME         Get the lifetime of the messages.
 OP_BLOCK_FLAGS      Get the flags for the rest of blocks.
 OP_DEST             Get the destination of the messages.
 OP_SOURCE           Get the source of the message.
 OP_REPORT           Get the report of the message.
 OP_CUSTOM           Get the custom value of the message.
 OP_LAST_TIMESTAMP   Get the last message timestamp.
</pre><p>errno can take the values below:</p>
<ul>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>ENOTSUP invalid option. </li>
</ul>

</div>
</div>
<a class="anchor" id="abad4189d4d9c65c2ccba478f6bcf184d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_recv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recive a message. </p>
<p>Recive a message from adtn_socket. If at the moment of perform the call there are no messages adtn_recv(3) will block until can retrieve a message. After get a message it will be deleted from the socket queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket. </td></tr>
    <tr><td class="paramname">buffer</td><td>array where the mssg value will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes that will be written into buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received on succes or -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>EINVAL invalid buffer or len. </li>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>ENOENT cannot load the shared memory. </li>
</ul>

</div>
</div>
<a class="anchor" id="a299b065f549a34acddf22976959737fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_recvfrom </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsock__addr__t.html">sock_addr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recive a message, filling sender information. </p>
<p>Recive a message from adtn_socket. If at the moment of perform the call there are no messages adtn_recvfrom(4) will block until can retrieve a message. After get a message it will be deleted from the socket queue. A <a class="el" href="structsock__addr__t.html">sock_addr_t</a> struct will be fill with sender information like ip or port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket. </td></tr>
    <tr><td class="paramname">buffer</td><td>array where the mssg value will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes that will be written into buffer. </td></tr>
    <tr><td class="paramname">addr</td><td>An empty structure that will be filled with information about the sender.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received on succes or -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>EINVAL invalid buffer or len. </li>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>ENOENT cannot load the shared memory. </li>
</ul>

</div>
</div>
<a class="anchor" id="af4cad55c5318074fb976e192a9aef2a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_rmcodopt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an associated code from a socket. </p>
<p>Allows to remove an associated code from a socket. See documentation of adtn_setcodopt(1) for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket. </td></tr>
    <tr><td class="paramname">option_name</td><td>determines what kind of code will be removed. If the code doesn't exist nothing happens.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>EINVAL invalid code option. </li>
</ul>

</div>
</div>
<a class="anchor" id="a418c2b08965709b2ee2e3fc677163b11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_sendto </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsock__addr__t.html">sock_addr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message over ADTN platform. </p>
<p>Sends a message over ADTN platform. The fact that adtn_sendto call returns a success value doesn't mean that the message has been sent through the network. adtn_sendto(3) only puts the message in queue to be sent. The platform will manage the send through the network. In opportunistic networks the time until adtn_sendto(3) returns a succes value and the message is really send is impossible to determine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket. </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer with the message to send. </td></tr>
    <tr><td class="paramname">buffer_l</td><td>the length to send of the buffer. </td></tr>
    <tr><td class="paramname">addr</td><td><a class="el" href="structsock__addr__t.html">sock_addr_t</a> structure containing the destination information. Must contain, the application port and ip of the destination.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written on succes or -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>EINVAL invalid address or null buffer. </li>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>ENOENT cannot load the shared memory. </li>
<li>EMSGSIZE message size is too big. </li>
</ul>

</div>
</div>
<a class="anchor" id="a4a8928a10e0adc936b202de9b2c5a251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_setcodopt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate codes to a socket. </p>
<p>Over ADTN platform the messages can carry codes with him to perform different tasks. This function allows to add code options to the socket. Each code linked with the socket will be added to outcoming messages sent through the socket. The kind of code associated to the socket is specified by the parameter option_name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket. </td></tr>
    <tr><td class="paramname">option_name</td><td>determines what kind of code will be associated to the socket. R_CODE will add a routing code. This code will be executed in each hop of the network to determine the next hop. L_CODE will add a life time code. This code will be executed in each node of the network to decide if the message is lapsed or not. P_CODE will add a prioritzation code. This code will affect only to the messages in other nodes that pertain to same application. Is not possible for a code to priorize messages from other applications. </td></tr>
    <tr><td class="paramname">code</td><td>This parameter must contain the full code to associate to socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>EINVAL invalid code or from_file value. </li>
<li>EOPNOTSUPP existing code binded. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5e74a5f6f5753fba19c1f819409f0fa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_setcodopt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate codes to a socket. </p>
<p>Over ADTN platform the messages can carry codes with him to perform different tasks. This function allows to add code options to the socket. Each code linked with the socket will be added to outcoming messages sent through the socket. The kind of code associated to the socket is specified by the parameter option_name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket. </td></tr>
    <tr><td class="paramname">option_name</td><td>determines what kind of code will be associated to the socket. R_CODE will add a routing code. This code will be executed in each hop of the network to determine the next hop. L_CODE will add a life time code. This code will be executed in each node of the network to decide if the message is lapsed or not. P_CODE will add a prioritzation code. This code will affect only to the messages in other nodes that pertain to same application. Is not possible for a code to priorize messages from other applications. </td></tr>
    <tr><td class="paramname">code</td><td>This parameter must contain a filename where the code is stored or the full code to associate to socket. The content of this parameter is associated with parameter from_file. </td></tr>
    <tr><td class="paramname">from_file</td><td>If is set to 1 the param code will contain a filename where the routing code is stored. If is set to 0 the param code must contain all code. Default value is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>EINVAL invalid code or from_file value. </li>
<li>EOPNOTSUPP existing code binded. </li>
</ul>

</div>
</div>
<a class="anchor" id="afc689259089066625ac4e162d2eaa38a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_setcodopt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate codes to a socket. </p>
<p>Over ADTN platform the messages can carry codes with him to perform different tasks. This function allows to add code options to the socket. Each code linked with the socket will be added to outcoming messages sent through the socket. The kind of code associated to the socket is specified by the parameter option_name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket. </td></tr>
    <tr><td class="paramname">option_name</td><td>determines what kind of code will be associated to the socket. R_CODE will add a routing code. This code will be executed in each hop of the network to determine the next hop. L_CODE will add a life time code. This code will be executed in each node of the network to decide if the message is lapsed or not. P_CODE will add a prioritzation code. This code will affect only to the messages in other nodes that pertain to same application. Is not possible for a code to priorize messages from other applications. </td></tr>
    <tr><td class="paramname">code</td><td>This parameter must contain a filename where the code is stored or the full code to associate to socket. The content of this parameter is associated with parameter from_file. </td></tr>
    <tr><td class="paramname">from_file</td><td>If is set to 1 the param code will contain a filename where the routing code is stored. If is set to 0 the param code must contain all code. Default value is 0. </td></tr>
    <tr><td class="paramname">replace</td><td>If is set to 1 and exists an older code associated to the socket it will be replaced. If is set to 0 and a code is already binded with the socket this function will return an error. Replace is 0 by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>EINVAL invalid code or from_file value. </li>
<li>EOPNOTSUPP existing code binded. </li>
</ul>

</div>
</div>
<a class="anchor" id="a62e2c186f096e9aad28705002b212729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_setsockopt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>optval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set message options. </p>
<p>In ADTN messages is posible specify the lifetime of the message and diferents options for headers. These options can be associated to a socket using this function. After calling it, all messages send through the socket will ahve the specified options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket. </td></tr>
    <tr><td class="paramname">optname</td><td>determines the option to set, the possible values are listed below. </td></tr>
    <tr><td class="paramname">optval</td><td>the value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>Options available: </p>
<pre class="fragment"> OP_PROC_FLAGS       Set the flags for the primary block.
 OP_LIFETIME         Set the lifetime of the messages.
 OP_BLOCK_FLAGS      Set the flags for the rest of blocks.
 OP_DEST             Set the destination of the messages.
 OP_SOURCE           Set the source of the message.
 OP_REPORT           Set the report of the message.
 OP_CUSTOM           Set the custom value of the message.
</pre><p>errno can take the values below:</p>
<ul>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>ENOTSUP invalid option. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad717021a3a6e4ea0d5daeb0067976215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_shutdown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as adtn_close(1), deleting also waiting data. </p>
<p>Closes an adtn_socket and frees the memory associated to the socket. The structures associated to the socket in adtn_bind(2) call are freed too. If some data are waiting to be readed it will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor identifying the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>ENOTSOCK the file descriptor is not a valid adtn_socket descriptor. </li>
<li>ENOENT cannot load the shared memory. </li>
<li>EACCES the program hasn't enough permisions to eliminate the socket </li>
</ul>

</div>
</div>
<a class="anchor" id="a5f3b9e8c428a78ba02cb8c8898d8490c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a adtn sockets to send or recv information using the adtn platform with the default configuration. </p>
<p>aDTN is divided in two parts, one is the API for developers that allow to use functions to send and receive messages. The other one is the core that manages and sends the messages.</p>
<p>The Core makes posible resilience to delay, disruptions and big taxes of errors. The implementation of the platform allow more than one core to cohexist in the same node(device).</p>
<dl class="section return"><dt>Returns</dt><dd>a descriptor identifiyng the socket on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>EBUSY Cannot allocate socket. </li>
<li>ENOENT global configuration missing in configuration file. </li>
<li>EBADRQC data field missing in configuration file. </li>
</ul>

</div>
</div>
<a class="anchor" id="aaa097626513dd6ffd3e781adcf7d31e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adtn_socket </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>config_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a adtn sockets to send or recv information using the adtn platform. </p>
<p>aDTN is divided in two parts, one is the API for developers that allow to use functions to send and receive messages. The other one is the core that manages and sends the messages.</p>
<p>The Core makes posible resilience to delay, disruptions and big taxes of errors. The implementation of the platform allow more than one core to cohexist in the same node(device).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config_file</td><td>The configuration file path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a descriptor identifiyng the socket on succes, -1 on error. If the function fails errno is set.</dd></dl>
<p>errno can take the values below:</p>
<ul>
<li>EBUSY Cannot allocate socket. </li>
<li>ENOENT global configuration missing in configuration file. </li>
<li>EBADRQC data field missing in configuration file. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 1 2015 15:48:28 for aDTN lib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
